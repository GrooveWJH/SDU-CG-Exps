#import "@preview/codly:1.1.1": *
#import "@preview/codly-languages:0.1.1": *
#show: codly-init.with()
#codly(languages: codly-languages)

#set heading(numbering: "1.1")
#set page(paper: "a4", margin: (x: 4em, y: 4em))
#set text(font: "Kai")
#align(center)[#text(size: 20pt)[计算机图形学实验] \ #text(size: 10pt)[吴建豪]]
// #show: rest => columns(2, rest)

= 光栅图形学基础

== 光栅化概念
- 光栅化是将几何图形转换为像素表示的过程
- 基本任务是将连续的几何体离散化为像素点阵
- 需要考虑抗锯齿、采样等问题

= 直线段算法的英文名称及缩写

1. 基本增量算法
  - 英文名称: Digital Differential Analyzer (DDA) Algorithm
  - 缩写: DDA
  - 说明: DDA算法是一种基于增量计算的直线扫描转换方法，通过逐步增加一个坐标（通常是x或y），并计算另一个坐标的增量来绘制直线。它使用浮点运算，逻辑简单，适用于基础教学和理解扫描转换的基本原理。

2. 逐点比较法
  - 英文名称: Step-by-Step Point Comparison Method
  - 缩写: 不常用缩写
  - 说明: 逐点比较法通过逐步比较每个候选像素的位置，决定下一个应当点亮的像素点。这种方法类似于布雷森汉姆算法，但通常不具备特定的标准缩写。

3. Bresenham算法
  - 英文名称: Bresenham’s Line Algorithm
  - 缩写: Bresenham
  - 说明: 布雷森汉姆直线算法是一种高效的整数运算直线绘制方法，避免了浮点运算，适用于实时渲染和高性能需求。它通过误差累积机制，决定每一步应点亮哪个像素，确保直线的连贯性和精确性。

4. 中点画线法
  - 英文名称: Midpoint Line Drawing Algorithm
  - 缩写: Midpoint Algorithm
  - 说明: 中点画线算法通过计算直线中点的偏移量，决定下一个像素点的位置。与布雷森汉姆算法类似，它使用整数运算，提高了绘制效率和精度，适用于需要高质量直线渲染的应用场景。

= 圆算法的英文名称及缩写

1. 基于光栅的整圆绘制算法
  - 英文名称: Raster-Based Complete Circle Drawing Algorithm
  - 缩写: 不常用缩写
  - 说明: 这种算法通过光栅化技术，计算并绘制圆的所有像素点，确保圆形的完整性和对称性。适用于需要绘制高质量完整圆形的图形应用。

2. 绘制正缘的Bresenham算法
  - 英文名称: Bresenham’s Circle Drawing Algorithm
  - 缩写: Bresenham’s Circle Algorithm
  - 说明: 布雷森汉姆圆绘制算法是一种高效的整数运算方法，用于在光栅显示器上绘制圆形。它通过误差累积机制，决定每一步应点亮哪个像素，确保圆形的对称性和精确性。

3. 中点画圆法
  - 英文名称: Midpoint Circle Algorithm
  - 缩写: Midpoint Circle Algorithm
  - 说明: 中点画圆算法通过计算圆的中点偏移量，决定下一个像素点的位置。它使用整数运算，提高了绘制效率和精度，适用于需要高质量圆形渲染的应用场景。

= 圆弧算法的英文名称及缩写

1. 角度离散法
  - 英文名称: Angle Discretization Method
  - 缩写: Angle Discretization
  - 说明: 角度离散法通过将圆弧的角度范围离散化为小步长，逐步计算并绘制每个对应的像素点。这种方法简单直观，适用于基本的圆弧绘制需求。

2. 参数法
  - 英文名称: Parametric Method
  - 缩写: Parametric Algorithm
  - 说明: 参数法使用参数（通常是角度参数t）来同时表示x和y坐标，通过参数的变化来生成圆弧上的点。适用于需要灵活控制圆弧形状和位置的应用，如动画和复杂图形绘制。

3. 扫描转换算法
  - 英文名称: Scan Conversion Algorithm
  - 缩写: Scan Conversion
  - 说明: 扫描转换算法用于将几何描述（如圆弧）转换为光栅显示器上的像素表示。它通过逐行扫描和计算像素覆盖关系，确定应点亮的像素点。

4. 中点扫描转换算法
  - 英文名称: Midpoint Scan Conversion Algorithm
  - 缩写: Midpoint Scan Conversion
  - 说明: 中点扫描转换算法结合了中点算法和扫描转换技术，通过计算中点的偏移量，决定每一步应点亮哪个像素，确保圆弧的对称性和精确性。适用于需要高质量圆弧渲染的图形应用。

= 详细讲解及生动比喻

1. 直线段算法
  - DDA算法（Digital Differential Analyzer）：
    - 工作原理：像是在纸上用铅笔一步步画直线，每一步根据直线的斜率，计算下一个像素点的位置。
    - 优点：简单直观，易于理解和实现。
    - 缺点：使用浮点运算，速度较慢，可能产生舍入误差。
  - Bresenham算法：
    - 工作原理：类似于用直尺和计数器精确地绘制直线，通过整数运算决定每一步应点亮哪个像素，避免了浮点运算的复杂性。
    - 优点：高效、精确，适合实时渲染。
    - 缺点：实现稍微复杂，需要理解误差累积机制。
  - 中点画线法：
    - 工作原理：通过计算直线的中点偏移量，决定下一个像素点的位置，确保直线的连贯性和对称性。
    - 优点：效率高，适合需要高质量直线渲染的应用。
    - 缺点：实现复杂度较高，但与Bresenham算法类似，都是基于整数运算的高效方法。

2. 圆算法
  - Bresenham’s Circle Algorithm：
    - 工作原理：通过判断当前点的中点位置，决定下一个应点亮的像素，确保圆形的对称性。
    - 优点：高效、精确，适用于实时渲染。
    - 缺点：实现复杂，需要理解对称性和误差累积。
  - Midpoint Circle Algorithm：
    - 工作原理：类似于直线的中点算法，通过计算圆的中点偏移量，决定下一个像素点的位置。
    - 优点：效率高，适合高质量圆形渲染。
    - 缺点：需要基于整数运算，适用于需要精确控制的应用。

3. 圆弧算法
  - Angle Discretization Method：
    - 工作原理：将圆弧 的角度范围分成小步长，逐步计算并绘制每个角度对应的像素点。
    - 优点：实现简单，直观。
    - 缺点：效率较低，精度依赖于角度步长。
  - Parametric Method：
    - 工作原理：使用参数（如角度t）同时表示x和y坐标，通过参数的变化生成圆弧上的点。
    - 优点：灵活，适合复杂形状和动画。
    - 缺点：需要计算三角函数，效率较低。
  - Scan Conversion Algorithm：
    - 工作原理：通过逐行扫描和计算像素覆盖关系，确定应点亮的像素点。
    - 优点：适用于高质量图形渲染。
    - 缺点：实现复杂，计算量较大。
  - Midpoint Scan Conversion Algorithm：
    - 工作原理：结合中点算法和扫描转换，通过计算中点的偏移量，决定每一步应点亮哪个像素。
    - 优点：高效、精确，适用于需要高质量圆弧渲染的应用。
    - 缺点：实现复杂，需要理解中点和扫描转换的结合机制。

4. 生动比喻
  - 绘制直线：
    - DDA算法：想象你在用铅笔自由地画一条直线，每一步都根据斜率计算下一个点的位置。
    - Bresenham算法：像是使用带刻度的直尺，每一步精确地确定下一个像素点，避免手抖导致的误差。
  - 绘制圆：
    - Bresenham’s Circle Algorithm：想象你用一把量角器和铅笔，精确地在每个对称位置标记点，确保圆的完美对称。
    - Midpoint Circle Algorithm：类似于在画圆时，通过不断调整铅笔的位置，确保每个点都紧密地贴合圆的轮廓。
  - 绘制圆弧：
    - Angle Discretization Method：就像在绘制一个部分圆时，按刻度标记多个角度点，然后依次连接这些点。
    - Parametric Method：想象你手持画笔，随着时间的推移（参数t的变化），沿着预定的轨迹绘制出圆弧的每一个点。

总结：
  - 基本增量算法（DDA）、逐点比较法、Bresenham算法和中点画线法是直线段扫描转换的主要算法，每种算法在效率、精度和实现复杂度上各有优劣。
  - 基于光栅的整圆绘制算法、Bresenham的圆算法和中点画圆法是圆绘制的主要方法，确保了圆形的对称性和渲染效率。
  - 角度离散法、参数法、扫描转换算法和中点扫描转换算法是圆弧绘制的主要技术，适用于不同的应用需求和渲染质量要求。
  - 理解这些算法的英文名称及缩写，有助于在学习和应用计算机图形学时准确沟通和查找相关资料。

通过上述详细解释和生动比喻，希望你对这些图形扫描转换算法的英文名称及其应用有了更全面和直观的理解。



== 直线光栅化算法
=== DDA算法 (数字微分分析器)
DDA算法通过计算斜率并在每一步使用浮点数累加来模拟直线路径,本质上是用离散的点来逼近连续的直线.在每一步中,算法通过对浮点坐标进行四舍五入来确定最接近理想直线的整数像素坐标,这种简单的取整方式虽然可能在某些情况下不是最优选择,但保证了算法的简单性和直观性.

- 基本原理:
  - 基于浮点或定点的增量计算
  - 通过斜率计算逐步确定下一个像素位置
- 工作过程:
  #block(inset: (left: 2em))[
    1. 计算直线斜率 k = Δy/Δx
    2. 从起点开始,每次在x方向步进1个单位
    3. y坐标按斜率增加:y = y + k
    4. 将(x,y)转换为最近的整数坐标
  ]
- 特点:
  #block(inset: (left: 2em))[
    - 实现简单直观
    - 需要浮点运算
    - 效率相对较低
  ]

```cpp
void DDALine(int x1, int y1, int x2, int y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    float steps = abs(dx) > abs(dy) ? abs(dx) : abs(dy);
    // 计算每步的增量
    float xInc = dx / steps;
    float yInc = dy / steps;
    float x = x1, y = y1;
    for (int i = 0; i <= steps; i++) {
        putPixel(round(x), round(y)); // 绘制像素
        x += xInc;
        y += yInc;
    }
}
```

=== Bresenham算法
Bresenham算法通过累积误差项来选择最接近理想直线的像素点,巧妙地将浮点运算转化为整数运算,是一种高效的增量式算法.在每一步中,算法通过比较误差项与0的关系来决定是选择水平方向相邻的像素还是对角线方向的像素,这种选择方式保证了所选像素始终是距离理想直线最近的点,同时避免了浮点运算.

- 基本原理:
  - 使用整数增量法
  - 通过误差判定选择最接近直线的像素
- 工作过程:
  #block(inset: (left: 2em))[
    1. 假设当前在像素P(x,y)
    2. 下一个像素只有两个选择:
      - P1(x+1, y)
      - P2(x+1, y+1)
    3. 计算误差项:
      - 如果误差\<0,选择P1
      - 如果误差≥0,选择P2
    4. 更新误差项(只需整数加减)
  ]
- 特点:
  #block(inset: (left: 2em))[
    - 仅使用整数运算
    - 避免浮点运算开销
    - 效率高,适合硬件实现
    - 是最常用的直线光栅化算法
  ]

```cpp
void BresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy;

    while (true) {
        putPixel(x1, y1); // 绘制像素
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}
```

=== 中点算法 (Midpoint)
中点算法基于几何直观,通过判断候选像素中点与理想直线的位置关系来选择最优像素,提供了一种更易理解的方式来实现直线光栅化.算法在每一步都计算两个候选像素中点相对于理想直线的位置,如果中点在直线上方,说明直线更接近下方像素,反之则选择上方像素,这种基于几何关系的选择方式直观地保证了像素选择的最优性.

- 基本原理:
  - 使用中点判别函数
  - 根据中点位置决定像素选择
- 工作过程:
  #block(inset: (left: 2em))[
    1. 考虑当前像素P(x,y)右边的两个候选像素
    2. 计算它们中点M的位置
    3. 判断M与理想直线的位置关系:
      - 如果M在直线上方,选择下方像素
      - 如果M在直线下方,选择上方像素
  ]
- 几何意义:
  #block(inset: (left: 2em))[
    - 通过中点到直线的距离判断
    - 保证选择的像素最接近理想直线
    - 本质上与Bresenham算法等价
  ]
- 特点:
  #block(inset: (left: 2em))[
    - 思想与Bresenham算法相近
    - 便于理解增量式判别思想
    - 可推广到圆和其他曲线的光栅化
  ]

```cpp
void MidpointLine(int x1, int y1, int x2, int y2) {
    int dx = x2 - x1, dy = y2 - y1, d = dy - (dx / 2);
    int x = x1, y = y1;
    putPixel(x, y); // 绘制第一个像素
    while (x < x2) {
        x++;
        if (d < 0) d += dy;
        else {
            d += (dy - dx);
            y++;
        }
        putPixel(x, y); // 绘制像素
    }
}
```

= 着色器基础

== 着色器概念
- 定义: 着色器是运行在图形处理单元(GPU)上的小程序,用于控制图形渲染管线中的各个阶段。它们负责处理顶点、几何体和像素等数据,以生成最终的图像。
- 功能:
  - 顶点处理: 变换顶点位置、计算光照等。
  - 几何处理: 生成新的几何体、进行几何变换等。
  - 片元处理: 计算每个像素的颜色、处理纹理等。
- 编程语言: 常见的着色器编程语言包括 GLSL(OpenGL Shading Language)、HLSL(High-Level Shading Language, 用于DirectX)、和 SPIR-V(用于Vulkan)。
- 可编程性: 着色器提供了高度的灵活性,允许开发者自定义图形渲染效果,如实时光照、阴影、反射、折射等。

== 顶点着色器
- 职责:
  - 顶点变换: 将顶点从模型空间(Model Space)转换到世界空间(World Space)、视图空间(View Space)和裁剪空间(Clip Space)。
  - 法线计算: 计算和传递顶点的法线向量,用于后续的光照计算。
  - 属性传递: 传递顶点属性,如颜色、纹理坐标等,供后续着色器使用。
- 输入:
  - 顶点属性: 位置(Position)、法线(Normal)、颜色(Color)、纹理坐标(Texture Coordinates)等。
  - 变换矩阵: 模型矩阵(Model Matrix)、视图矩阵(View Matrix)、投影矩阵(Projection Matrix)。
- 输出:
  - 裁剪空间位置: 用于光栅化阶段的顶点位置。
  - 顶点属性: 传递给几何着色器或片元着色器的属性。

== 几何着色器
- 职责:
  - 生成新几何体: 可以根据输入的几何体(如点、线、三角形)生成新的几何体,如额外的点、线段或三角形。
  - 几何变换: 进行复杂的几何变换,如法线细分、平滑、扩展等。
  - 特效生成: 实现几何体的动态效果,如爆炸效果、粒子生成等。
- 输入:
  - 基元类型: 顶点着色器输出的基元,如点(Points)、线(Lines)、三角形(Triangles)。
- 输出:
  - 新基元类型: 生成的基元类型,可以与输入基元类型相同或不同。
- 应用场景:
  - 几何体细分: 增加几何体的细节,提高渲染质量。
  - 动态几何体生成: 根据需要动态生成或修改几何体,如生成树枝、建筑结构等。

== 曲面细分着色器
- 职责:
  - 细分控制: 决定如何细分输入的几何体,控制细分级别和方式。
  - 细分评估: 计算细分后的新顶点的位置,生成更细腻的曲面。
- 组成部分:
  - 细分控制着色器(Tessellation Control Shader, TCS): 控制细分级别,决定每个细分区块的细分参数。
  - 细分评估着色器(Tessellation Evaluation Shader, TES): 计算细分后新顶点的位置,进行曲面评估。
- 应用场景:
  - 高精度曲面: 用于需要高精度和平滑曲面的场景,如角色模型、复杂地形等。
  - 动态细分: 根据视距或其他参数动态调整细分级别,提高渲染效率。

== 片元着色器
- 职责:
  - 颜色计算: 计算每个片元(像素)的最终颜色,包括光照、纹理、颜色混合等。
  - 纹理映射: 应用纹理图像到几何体表面,实现复杂的表面细节。
  - 光照模型: 实现不同的光照模型,如Phong光照、Blinn-Phong光照、PBR(基于物理的渲染)等。
- 输入:
  - 插值属性: 从顶点着色器或几何着色器传递下来的插值属性,如颜色、法线、纹理坐标等。
- 输出:
  - 片元颜色: 最终显示在屏幕上的颜色值。
- 应用场景:
  - 真实感渲染: 通过复杂的光照和材质计算,实现高度真实感的图像。
  - 后处理效果: 实现各种后处理效果,如模糊、边缘检测、颜色校正等。

== 图形渲染管线
- 定义: 图形渲染管线是将三维场景转换为二维图像的过程,涉及多个阶段,每个阶段处理不同类型的数据,并在GPU上高效执行。
- 主要阶段:
  + 顶点处理:
    - 任务: 处理顶点数据,进行变换和光照计算。
    - 涉及的着色器: 顶点着色器。
  + 图元装配:
    - 任务: 将顶点组装成基本图元,如点、线、三角形。
  + 几何处理:
    - 任务: 对图元进行进一步处理,如剔除、细分。
    - 涉及的着色器: 几何着色器(可选)。
  + 光栅化:
    - 任务: 将图元转换为片元,准备进行像素级处理。
  + 片元处理:
    - 任务: 计算每个片元的最终颜色,应用纹理、光照等效果。
    - 涉及的着色器: 片元着色器。
  + 测试与混合:
    - 任务: 进行深度测试、模板测试,混合片元颜色,实现透明效果等。
- 渲染管线的可编程性:
  - 通过着色器程序,开发者可以在管线的不同阶段插入自定义的计算逻辑,实现各种视觉效果。
- 性能优化:
  - 并行处理: 管线的每个阶段都在GPU上并行执行,充分利用GPU的计算能力。
  - 管线效率: 通过减少不必要的计算和优化着色器代码,提高渲染效率。

== 着色器编程实例

为了更好地理解各类着色器的作用,以下提供一个简单的着色器编程实例,展示顶点着色器和片元着色器的配合。

顶点着色器示例(GLSL)
- 接收每个顶点的位置和颜色属性。
- 使用模型、视图和投影矩阵将顶点位置转换到裁剪空间。
- 将顶点颜色传递给片元着色器。

片元着色器示例(GLSL)
- 接收从顶点着色器传递过来的颜色。
- 将颜色赋值给片元的最终颜色输出,实现颜色插值效果。

渲染流程
1. 顶点着色器对每个顶点进行处理,计算其在屏幕上的位置,并传递颜色信息。
2. 光栅化将顶点组成的图元转换为片元。
3. 片元着色器对每个片元进行颜色计算,最终形成图像。

== 高级着色器技术

随着图形渲染需求的提升,着色器技术也不断发展,涌现出许多高级技术,提升图形质量和渲染效率。

+ 光照模型
  - Phong光照模型: 基于反射定律,计算环境光、漫反射光和镜面反射光。
  - Blinn-Phong光照模型: 对镜面反射进行了优化,通过计算半程向量来简化计算。
  - PBR(基于物理的渲染): 采用物理上准确的光照和材质模型,提供更真实的渲染效果。

+ 纹理技术
  - 多重纹理映射: 结合多个纹理,实现复杂的表面效果,如混合不同材质、法线贴图等。
  - 法线贴图(Normal Mapping): 使用法线贴图增加表面细节,模拟凹凸感而无需增加几何体。
  - 环境映射(Environment Mapping): 实现反射和折射效果,如镜面反射、水面反射等。
  - 纹理压缩: 通过压缩技术减少纹理内存占用,提高渲染性能。

+ 后处理效果
  - 抗锯齿(Anti-Aliasing): 减少边缘锯齿,提高图像质量。
  - 景深(Depth of Field): 模拟真实相机的景深效果,突出前景或背景。
  - 动态模糊(Motion Blur): 模拟快速移动物体的模糊效果,增强运动感。
  - HDR(高动态范围)渲染: 支持更宽的亮度范围,提升图像的亮部和暗部细节。
  - 屏幕空间反射(SSR): 实现基于屏幕空间的反射效果,提升反射的真实性。

+ 计算着色器(Compute Shaders)
  - 定义: 计算着色器是一种通用的着色器,用于执行并行计算任务,不限于图形渲染管线。
  - 应用场景: 物理模拟、图像处理、人工智能等。

+ 可编程几何着色器
  - 实例化: 在几何着色器中实例化图元,生成多个副本,节省内存并提高渲染效率。
  - 动态生成: 根据需要动态生成复杂的几何体,如草地、树木、粒子效果等。

+ 混合与透明度
  - 混合模式: 实现不同的混合效果,如加法混合、乘法混合、Alpha混合等。
  - 透明度排序: 处理透明对象的渲染顺序,确保正确的视觉效果。
  - 双面渲染: 渲染几何体的双面,提高视觉效果,如叶片、薄膜等。

+ 着色器优化
  - 减少分支: 尽量减少条件判断,使用数学函数替代分支,提升性能。
  - 内存访问优化: 合理使用纹理缓存和共享内存,减少全局内存访问,提高数据访问效率。
  - 并行计算: 利用GPU的并行计算能力,优化算法以充分发挥硬件性能。

= 杂项

== 贝塞尔曲线

=== 定义
贝塞尔曲线是一种参数曲线,广泛应用于计算机图形学和图像处理。

=== 特点
贝塞尔曲线由一组控制点定义,通过这些控制点的线性组合生成曲线。

=== 类型
- 一次贝塞尔曲线: 由两个控制点定义,生成一条直线。
- 二次贝塞尔曲线: 由三个控制点定义,生成一条抛物线。
- 三次贝塞尔曲线: 由四个控制点定义,生成一条更复杂的曲线。

=== 应用
贝塞尔曲线常用于路径动画、形状插值、字体设计等领域。

== 优点
贝塞尔曲线计算简单,易于实现平滑过渡和精确控制。


== 变换矩阵

=== 矩阵乘法
在计算机图形学中,矩阵乘法是进行几何变换的基础。通过矩阵乘法,可以实现顶点的平移、旋转、缩放等操作。

=== 变换矩阵
变换矩阵用于对几何体进行各种变换操作,如平移、旋转、缩放等。常见的变换矩阵包括平移矩阵、旋转矩阵和缩放矩阵。


=== 二维旋转矩阵
在二维空间中,旋转可以用一个单一的角θ定义。作为约定,正角表示逆时针旋转。把笛卡尔坐标的列向量关于原点逆时针旋转θ的矩阵是:

$
  M(theta) = mat(cos theta, -sin theta;sin theta ,cos theta) = cos theta mat(1,0;0,1) + sin theta mat(0, -1 ;1,0) = e (theta mat(0,-1;1,0))
$


== 样条曲线

=== Korchanek-Baetels 样条
Korchanek-Baetels 样条是一种通过控制张力、偏移和连续性参数来生成平滑曲线的方法。它允许用户对曲线的形状进行精细控制。

- 特点:
  - 张力参数: 控制曲线的紧张程度。
  - 偏移参数: 控制曲线的偏移量。
  - 连续性参数: 控制曲线的平滑程度。

=== Hermite插值样条
Hermite插值样条通过指定每个控制点的切线来生成曲线。它在控制点处具有连续的一阶导数,因此可以生成平滑的曲线。

- 特点:
  - 控制点: 指定曲线经过的点。
  - 切线: 指定每个控制点的切线方向和大小。

=== Cardinal 样条
Cardinal 样条是一种特殊的Catmull-Rom样条,通过一个张力参数来控制曲线的形状。它在控制点处具有连续的一阶导数。

- 特点:
  - 张力参数: 控制曲线的紧张程度。
  - 控制点: 指定曲线经过的点。

=== 自然三次样条
自然三次样条是一种通过最小化曲线的二阶导数来生成平滑曲线的方法。它在控制点处具有连续的二阶导数,因此可以生成非常平滑的曲线。

- 特点:
  - 控制点: 指定曲线经过的点。
  - 平滑性: 通过最小化二阶导数来保证曲线的平滑性。

== 多边形扫描转换算法

=== 题目
下列有关多边形扫描转换算法的论述哪些是正确的( )
  - A. 为了提高算法效率,引进了一套数据结构,如活性边表,新边表等
  - B. 多边形扫描转换算法适合于凸多边形
  - C. 多边形扫描转换的目的是把多边形的“点阵”表示转换为“项点”表示
  - D. 多边形扫描转换有:求交、排序、配对填色等步骤,其中排序运算最大

=== 选项分析

A. 为了提高算法效率,引进了一套数据结构,如活性边表,新边表等
  - 分析:在多边形扫描转换算法中,*活性边表(Active Edge Table, AET)和边表(Edge Table, ET)* 是关键的数据结构,用于有效管理和处理多边形的边信息。这些数据结构能够显著提高算法的效率,特别是在处理复杂多边形时。
  - 结论:正确

B. 多边形扫描转换算法适合于凸多边形
  - 分析:虽然多边形扫描转换算法确实适用于凸多边形,但其应用并不限于凸多边形。该算法同样适用于凹多边形,甚至是自相交多边形。选项B的表述可能给人一种算法仅适用于凸多边形的误导。
  - 结论:不完全正确

C. 多边形扫描转换的目的是把多边形的“点阵”表示转换为“项点”表示
  - 分析:多边形扫描转换的主要目的是将矢量表示(向量图形)的多边形转换为栅格表示(像素图形),即从数学定义的几何形状转变为屏幕上的像素填充。选项C中的“点阵”与“项点”表述不够准确,且容易引起混淆。
  - 结论:不正确

D. 多边形扫描转换有:求交、排序、配对填色等步骤,其中排序运算最大
  - 分析:多边形扫描转换算法通常包括以下几个步骤:
    1. 求交:计算扫描线与多边形边的交点。
    2. 排序:根据交点的x坐标进行排序。
    3. 配对:将交点成对配对,确定填充区域。
    4. 填色:对配对区间内的像素进行填充。
  在这些步骤中,排序运算通常是计算量最大的部分,尤其是在处理具有大量边的复杂多边形时。
  - 结论:正确

=== 最终结论
选项A和D是正确的。
